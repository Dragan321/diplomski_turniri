//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { DateTime, Duration } from "luxon";

export class GenerateDataClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    genData(): Promise<string> {
        let url_ = this.baseUrl + "/api/GenerateData";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenData(_response);
        });
    }

    protected processGenData(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class GoloviClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getGos(): Promise<Go[]> {
        let url_ = this.baseUrl + "/api/Golovi";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGos(_response);
        });
    }

    protected processGetGos(response: Response): Promise<Go[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(Go.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Go[]>(null as any);
    }

    postGo(go: PostGo): Promise<Go> {
        let url_ = this.baseUrl + "/api/Golovi";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(go);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostGo(_response);
        });
    }

    protected processPostGo(response: Response): Promise<Go> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = Go.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Go>(null as any);
    }

    getGo(id: number): Promise<Go> {
        let url_ = this.baseUrl + "/api/Golovi/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGo(_response);
        });
    }

    protected processGetGo(response: Response): Promise<Go> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = Go.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Go>(null as any);
    }

    putGo(id: number, go: Go): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Golovi/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(go);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutGo(_response);
        });
    }

    protected processPutGo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    deleteGo(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Golovi/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteGo(_response);
        });
    }

    protected processDeleteGo(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class IgraciClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getIgrace(searchTerm: string | null | undefined, pageSize: number | undefined, cursor: number | undefined, timids: number[] | null | undefined): Promise<IgraciResponseDto[]> {
        let url_ = this.baseUrl + "/api/Igraci?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (cursor === null)
            throw new Error("The parameter 'cursor' cannot be null.");
        else if (cursor !== undefined)
            url_ += "cursor=" + encodeURIComponent("" + cursor) + "&";
        if (timids !== undefined && timids !== null)
            timids && timids.forEach(item => { url_ += "timids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIgrace(_response);
        });
    }

    protected processGetIgrace(response: Response): Promise<IgraciResponseDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(IgraciResponseDto.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IgraciResponseDto[]>(null as any);
    }

    postIgrac(ime: string | null | undefined, email: string | null | undefined, tim: number | null | undefined, datumRodjenja: DateTime | undefined, slika: FileParameter | null | undefined): Promise<Igrac> {
        let url_ = this.baseUrl + "/api/Igraci";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (ime !== null && ime !== undefined)
            content_.append("ime", ime.toString());
        if (email !== null && email !== undefined)
            content_.append("email", email.toString());
        if (tim !== null && tim !== undefined)
            content_.append("tim", tim.toString());
        if (datumRodjenja === null || datumRodjenja === undefined)
            throw new Error("The parameter 'datumRodjenja' cannot be null.");
        else
            content_.append("datumRodjenja", datumRodjenja.toJSON());
        if (slika !== null && slika !== undefined)
            content_.append("slika", slika.data, slika.fileName ? slika.fileName : "slika");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostIgrac(_response);
        });
    }

    protected processPostIgrac(response: Response): Promise<Igrac> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = Igrac.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Igrac>(null as any);
    }

    getIgrac(id: number): Promise<SingleIgracResponseDto> {
        let url_ = this.baseUrl + "/api/Igraci/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIgrac(_response);
        });
    }

    protected processGetIgrac(response: Response): Promise<SingleIgracResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = SingleIgracResponseDto.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SingleIgracResponseDto>(null as any);
    }

    putIgrac(id: number, igrac: Igrac): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Igraci/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(igrac);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutIgrac(_response);
        });
    }

    protected processPutIgrac(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    deleteIgrac(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Igraci/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteIgrac(_response);
        });
    }

    protected processDeleteIgrac(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class MeceviClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getMecs(): Promise<Mec[]> {
        let url_ = this.baseUrl + "/api/Mecevi";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMecs(_response);
        });
    }

    protected processGetMecs(response: Response): Promise<Mec[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(Mec.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Mec[]>(null as any);
    }

    postMec(mec: Mec): Promise<Mec> {
        let url_ = this.baseUrl + "/api/Mecevi";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(mec);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostMec(_response);
        });
    }

    protected processPostMec(response: Response): Promise<Mec> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = Mec.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Mec>(null as any);
    }

    getMec(id: number): Promise<Mec> {
        let url_ = this.baseUrl + "/api/Mecevi/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMec(_response);
        });
    }

    protected processGetMec(response: Response): Promise<Mec> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = Mec.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Mec>(null as any);
    }

    zavrsiMec(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Mecevi/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processZavrsiMec(_response);
        });
    }

    protected processZavrsiMec(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    deleteMec(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Mecevi/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteMec(_response);
        });
    }

    protected processDeleteMec(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class TimoviClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTimove(searchTerm: string | null | undefined, pageSize: number | undefined, cursor: number | undefined): Promise<TimoviResponseDto[]> {
        let url_ = this.baseUrl + "/api/Timovi?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (cursor === null)
            throw new Error("The parameter 'cursor' cannot be null.");
        else if (cursor !== undefined)
            url_ += "cursor=" + encodeURIComponent("" + cursor) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTimove(_response);
        });
    }

    protected processGetTimove(response: Response): Promise<TimoviResponseDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(TimoviResponseDto.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TimoviResponseDto[]>(null as any);
    }

    postTim(nazivTima: string | null | undefined, email: string | null | undefined, logo: FileParameter | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Timovi";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (nazivTima !== null && nazivTima !== undefined)
            content_.append("NazivTima", nazivTima.toString());
        if (email !== null && email !== undefined)
            content_.append("Email", email.toString());
        if (logo !== null && logo !== undefined)
            content_.append("Logo", logo.data, logo.fileName ? logo.fileName : "Logo");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostTim(_response);
        });
    }

    protected processPostTim(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    getTim(id: number): Promise<SingleTimResponseDto> {
        let url_ = this.baseUrl + "/api/Timovi/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTim(_response);
        });
    }

    protected processGetTim(response: Response): Promise<SingleTimResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = SingleTimResponseDto.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SingleTimResponseDto>(null as any);
    }

    putTim(id: number, tim: Tim): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Timovi/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tim);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutTim(_response);
        });
    }

    protected processPutTim(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    deleteTim(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Timovi/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTim(_response);
        });
    }

    protected processDeleteTim(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class TurniriClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTurnirs(searchTerm: string | null | undefined, pageSize: number | undefined, cursor: number | undefined): Promise<TurniriResponseDto[]> {
        let url_ = this.baseUrl + "/api/Turniri?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (cursor === null)
            throw new Error("The parameter 'cursor' cannot be null.");
        else if (cursor !== undefined)
            url_ += "cursor=" + encodeURIComponent("" + cursor) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTurnirs(_response);
        });
    }

    protected processGetTurnirs(response: Response): Promise<TurniriResponseDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(TurniriResponseDto.fromJS(item));
                }
                else {
                    result200 = <any>null;
                }
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TurniriResponseDto[]>(null as any);
    }

    postTurnir(turnir: PostTurnirDTO): Promise<Turnir> {
        let url_ = this.baseUrl + "/api/Turniri";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(turnir);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostTurnir(_response);
        });
    }

    protected processPostTurnir(response: Response): Promise<Turnir> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = Turnir.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Turnir>(null as any);
    }

    getTurnir(id: number): Promise<SingleTurnirResponseDto> {
        let url_ = this.baseUrl + "/api/Turniri/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTurnir(_response);
        });
    }

    protected processGetTurnir(response: Response): Promise<SingleTurnirResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = SingleTurnirResponseDto.fromJS(resultData200);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SingleTurnirResponseDto>(null as any);
    }

    putTurnir(id: number, status: string | null | undefined, listaTimova: number[]): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Turniri/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listaTimova);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutTurnir(_response);
        });
    }

    protected processPutTurnir(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    deleteTurnir(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Turniri/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTurnir(_response);
        });
    }

    protected processDeleteTurnir(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class Go implements IGo {
    idGola?: number;
    idIgraca?: number | undefined;
    idTima?: number | undefined;
    idMeca?: number | undefined;
    minut?: number;
    idIgracaNavigation?: Igrac | undefined;
    idMecaNavigation?: Mec | undefined;
    idTimaNavigation?: Tim | undefined;

    constructor(data?: IGo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idGola = _data["idGola"];
            this.idIgraca = _data["idIgraca"];
            this.idTima = _data["idTima"];
            this.idMeca = _data["idMeca"];
            this.minut = _data["minut"];
            this.idIgracaNavigation = _data["idIgracaNavigation"] ? Igrac.fromJS(_data["idIgracaNavigation"]) : <any>undefined;
            this.idMecaNavigation = _data["idMecaNavigation"] ? Mec.fromJS(_data["idMecaNavigation"]) : <any>undefined;
            this.idTimaNavigation = _data["idTimaNavigation"] ? Tim.fromJS(_data["idTimaNavigation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Go {
        data = typeof data === 'object' ? data : {};
        let result = new Go();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idGola"] = this.idGola;
        data["idIgraca"] = this.idIgraca;
        data["idTima"] = this.idTima;
        data["idMeca"] = this.idMeca;
        data["minut"] = this.minut;
        data["idIgracaNavigation"] = this.idIgracaNavigation ? this.idIgracaNavigation.toJSON() : <any>undefined;
        data["idMecaNavigation"] = this.idMecaNavigation ? this.idMecaNavigation.toJSON() : <any>undefined;
        data["idTimaNavigation"] = this.idTimaNavigation ? this.idTimaNavigation.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGo {
    idGola?: number;
    idIgraca?: number | undefined;
    idTima?: number | undefined;
    idMeca?: number | undefined;
    minut?: number;
    idIgracaNavigation?: Igrac | undefined;
    idMecaNavigation?: Mec | undefined;
    idTimaNavigation?: Tim | undefined;
}

export class Igrac implements IIgrac {
    idIgraca?: number;
    idTima?: number | undefined;
    email?: string | undefined;
    imeIgraca?: string;
    datumRodjenja?: DateTime;
    slika?: string | undefined;
    emailNavigation?: Korisnik | undefined;
    gos?: Go[];
    idTimaNavigation?: Tim | undefined;

    constructor(data?: IIgrac) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idIgraca = _data["idIgraca"];
            this.idTima = _data["idTima"];
            this.email = _data["email"];
            this.imeIgraca = _data["imeIgraca"];
            this.datumRodjenja = _data["datumRodjenja"] ? DateTime.fromISO(_data["datumRodjenja"].toString()) : <any>undefined;
            this.slika = _data["slika"];
            this.emailNavigation = _data["emailNavigation"] ? Korisnik.fromJS(_data["emailNavigation"]) : <any>undefined;
            if (Array.isArray(_data["gos"])) {
                this.gos = [] as any;
                for (let item of _data["gos"])
                    this.gos!.push(Go.fromJS(item));
            }
            this.idTimaNavigation = _data["idTimaNavigation"] ? Tim.fromJS(_data["idTimaNavigation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Igrac {
        data = typeof data === 'object' ? data : {};
        let result = new Igrac();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idIgraca"] = this.idIgraca;
        data["idTima"] = this.idTima;
        data["email"] = this.email;
        data["imeIgraca"] = this.imeIgraca;
        data["datumRodjenja"] = this.datumRodjenja ? this.datumRodjenja.toString() : <any>undefined;
        data["slika"] = this.slika;
        data["emailNavigation"] = this.emailNavigation ? this.emailNavigation.toJSON() : <any>undefined;
        if (Array.isArray(this.gos)) {
            data["gos"] = [];
            for (let item of this.gos)
                data["gos"].push(item.toJSON());
        }
        data["idTimaNavigation"] = this.idTimaNavigation ? this.idTimaNavigation.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIgrac {
    idIgraca?: number;
    idTima?: number | undefined;
    email?: string | undefined;
    imeIgraca?: string;
    datumRodjenja?: DateTime;
    slika?: string | undefined;
    emailNavigation?: Korisnik | undefined;
    gos?: Go[];
    idTimaNavigation?: Tim | undefined;
}

export class Korisnik implements IKorisnik {
    email?: string;
    ime?: string;
    igracs?: Igrac[];
    tims?: Tim[];
    turnirs?: Turnir[];

    constructor(data?: IKorisnik) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.ime = _data["ime"];
            if (Array.isArray(_data["igracs"])) {
                this.igracs = [] as any;
                for (let item of _data["igracs"])
                    this.igracs!.push(Igrac.fromJS(item));
            }
            if (Array.isArray(_data["tims"])) {
                this.tims = [] as any;
                for (let item of _data["tims"])
                    this.tims!.push(Tim.fromJS(item));
            }
            if (Array.isArray(_data["turnirs"])) {
                this.turnirs = [] as any;
                for (let item of _data["turnirs"])
                    this.turnirs!.push(Turnir.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Korisnik {
        data = typeof data === 'object' ? data : {};
        let result = new Korisnik();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["ime"] = this.ime;
        if (Array.isArray(this.igracs)) {
            data["igracs"] = [];
            for (let item of this.igracs)
                data["igracs"].push(item.toJSON());
        }
        if (Array.isArray(this.tims)) {
            data["tims"] = [];
            for (let item of this.tims)
                data["tims"].push(item.toJSON());
        }
        if (Array.isArray(this.turnirs)) {
            data["turnirs"] = [];
            for (let item of this.turnirs)
                data["turnirs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IKorisnik {
    email?: string;
    ime?: string;
    igracs?: Igrac[];
    tims?: Tim[];
    turnirs?: Turnir[];
}

export class Tim implements ITim {
    idTima?: number;
    email?: string | undefined;
    nazivTima?: string;
    logo?: string | undefined;
    emailNavigation?: Korisnik | undefined;
    gos?: Go[];
    igracs?: Igrac[];
    mecIdTimaNavigations?: Mec[];
    mecTimIdTima2Navigations?: Mec[];
    mecTimIdTimaNavigations?: Mec[];
    idTurniras?: Turnir[];

    constructor(data?: ITim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idTima = _data["idTima"];
            this.email = _data["email"];
            this.nazivTima = _data["nazivTima"];
            this.logo = _data["logo"];
            this.emailNavigation = _data["emailNavigation"] ? Korisnik.fromJS(_data["emailNavigation"]) : <any>undefined;
            if (Array.isArray(_data["gos"])) {
                this.gos = [] as any;
                for (let item of _data["gos"])
                    this.gos!.push(Go.fromJS(item));
            }
            if (Array.isArray(_data["igracs"])) {
                this.igracs = [] as any;
                for (let item of _data["igracs"])
                    this.igracs!.push(Igrac.fromJS(item));
            }
            if (Array.isArray(_data["mecIdTimaNavigations"])) {
                this.mecIdTimaNavigations = [] as any;
                for (let item of _data["mecIdTimaNavigations"])
                    this.mecIdTimaNavigations!.push(Mec.fromJS(item));
            }
            if (Array.isArray(_data["mecTimIdTima2Navigations"])) {
                this.mecTimIdTima2Navigations = [] as any;
                for (let item of _data["mecTimIdTima2Navigations"])
                    this.mecTimIdTima2Navigations!.push(Mec.fromJS(item));
            }
            if (Array.isArray(_data["mecTimIdTimaNavigations"])) {
                this.mecTimIdTimaNavigations = [] as any;
                for (let item of _data["mecTimIdTimaNavigations"])
                    this.mecTimIdTimaNavigations!.push(Mec.fromJS(item));
            }
            if (Array.isArray(_data["idTurniras"])) {
                this.idTurniras = [] as any;
                for (let item of _data["idTurniras"])
                    this.idTurniras!.push(Turnir.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Tim {
        data = typeof data === 'object' ? data : {};
        let result = new Tim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idTima"] = this.idTima;
        data["email"] = this.email;
        data["nazivTima"] = this.nazivTima;
        data["logo"] = this.logo;
        data["emailNavigation"] = this.emailNavigation ? this.emailNavigation.toJSON() : <any>undefined;
        if (Array.isArray(this.gos)) {
            data["gos"] = [];
            for (let item of this.gos)
                data["gos"].push(item.toJSON());
        }
        if (Array.isArray(this.igracs)) {
            data["igracs"] = [];
            for (let item of this.igracs)
                data["igracs"].push(item.toJSON());
        }
        if (Array.isArray(this.mecIdTimaNavigations)) {
            data["mecIdTimaNavigations"] = [];
            for (let item of this.mecIdTimaNavigations)
                data["mecIdTimaNavigations"].push(item.toJSON());
        }
        if (Array.isArray(this.mecTimIdTima2Navigations)) {
            data["mecTimIdTima2Navigations"] = [];
            for (let item of this.mecTimIdTima2Navigations)
                data["mecTimIdTima2Navigations"].push(item.toJSON());
        }
        if (Array.isArray(this.mecTimIdTimaNavigations)) {
            data["mecTimIdTimaNavigations"] = [];
            for (let item of this.mecTimIdTimaNavigations)
                data["mecTimIdTimaNavigations"].push(item.toJSON());
        }
        if (Array.isArray(this.idTurniras)) {
            data["idTurniras"] = [];
            for (let item of this.idTurniras)
                data["idTurniras"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITim {
    idTima?: number;
    email?: string | undefined;
    nazivTima?: string;
    logo?: string | undefined;
    emailNavigation?: Korisnik | undefined;
    gos?: Go[];
    igracs?: Igrac[];
    mecIdTimaNavigations?: Mec[];
    mecTimIdTima2Navigations?: Mec[];
    mecTimIdTimaNavigations?: Mec[];
    idTurniras?: Turnir[];
}

export class Mec implements IMec {
    idMeca?: number;
    idRunde?: number | undefined;
    idTima?: number | undefined;
    timIdTima?: number | undefined;
    timIdTima2?: number | undefined;
    idSledecegMeca?: number | undefined;
    mecZavrsen?: boolean;
    brGolovaTim1?: number | undefined;
    brGolovaTim2?: number | undefined;
    gos?: Go[];
    idRundeNavigation?: Runde | undefined;
    idTimaNavigation?: Tim | undefined;
    timIdTima2Navigation?: Tim | undefined;
    timIdTimaNavigation?: Tim | undefined;

    constructor(data?: IMec) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idMeca = _data["idMeca"];
            this.idRunde = _data["idRunde"];
            this.idTima = _data["idTima"];
            this.timIdTima = _data["timIdTima"];
            this.timIdTima2 = _data["timIdTima2"];
            this.idSledecegMeca = _data["idSledecegMeca"];
            this.mecZavrsen = _data["mecZavrsen"];
            this.brGolovaTim1 = _data["brGolovaTim1"];
            this.brGolovaTim2 = _data["brGolovaTim2"];
            if (Array.isArray(_data["gos"])) {
                this.gos = [] as any;
                for (let item of _data["gos"])
                    this.gos!.push(Go.fromJS(item));
            }
            this.idRundeNavigation = _data["idRundeNavigation"] ? Runde.fromJS(_data["idRundeNavigation"]) : <any>undefined;
            this.idTimaNavigation = _data["idTimaNavigation"] ? Tim.fromJS(_data["idTimaNavigation"]) : <any>undefined;
            this.timIdTima2Navigation = _data["timIdTima2Navigation"] ? Tim.fromJS(_data["timIdTima2Navigation"]) : <any>undefined;
            this.timIdTimaNavigation = _data["timIdTimaNavigation"] ? Tim.fromJS(_data["timIdTimaNavigation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Mec {
        data = typeof data === 'object' ? data : {};
        let result = new Mec();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idMeca"] = this.idMeca;
        data["idRunde"] = this.idRunde;
        data["idTima"] = this.idTima;
        data["timIdTima"] = this.timIdTima;
        data["timIdTima2"] = this.timIdTima2;
        data["idSledecegMeca"] = this.idSledecegMeca;
        data["mecZavrsen"] = this.mecZavrsen;
        data["brGolovaTim1"] = this.brGolovaTim1;
        data["brGolovaTim2"] = this.brGolovaTim2;
        if (Array.isArray(this.gos)) {
            data["gos"] = [];
            for (let item of this.gos)
                data["gos"].push(item.toJSON());
        }
        data["idRundeNavigation"] = this.idRundeNavigation ? this.idRundeNavigation.toJSON() : <any>undefined;
        data["idTimaNavigation"] = this.idTimaNavigation ? this.idTimaNavigation.toJSON() : <any>undefined;
        data["timIdTima2Navigation"] = this.timIdTima2Navigation ? this.timIdTima2Navigation.toJSON() : <any>undefined;
        data["timIdTimaNavigation"] = this.timIdTimaNavigation ? this.timIdTimaNavigation.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMec {
    idMeca?: number;
    idRunde?: number | undefined;
    idTima?: number | undefined;
    timIdTima?: number | undefined;
    timIdTima2?: number | undefined;
    idSledecegMeca?: number | undefined;
    mecZavrsen?: boolean;
    brGolovaTim1?: number | undefined;
    brGolovaTim2?: number | undefined;
    gos?: Go[];
    idRundeNavigation?: Runde | undefined;
    idTimaNavigation?: Tim | undefined;
    timIdTima2Navigation?: Tim | undefined;
    timIdTimaNavigation?: Tim | undefined;
}

export class Runde implements IRunde {
    idRunde?: number;
    idTurnira?: number | undefined;
    runda?: number;
    idTurniraNavigation?: Turnir | undefined;
    mecs?: Mec[];

    constructor(data?: IRunde) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idRunde = _data["idRunde"];
            this.idTurnira = _data["idTurnira"];
            this.runda = _data["runda"];
            this.idTurniraNavigation = _data["idTurniraNavigation"] ? Turnir.fromJS(_data["idTurniraNavigation"]) : <any>undefined;
            if (Array.isArray(_data["mecs"])) {
                this.mecs = [] as any;
                for (let item of _data["mecs"])
                    this.mecs!.push(Mec.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Runde {
        data = typeof data === 'object' ? data : {};
        let result = new Runde();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idRunde"] = this.idRunde;
        data["idTurnira"] = this.idTurnira;
        data["runda"] = this.runda;
        data["idTurniraNavigation"] = this.idTurniraNavigation ? this.idTurniraNavigation.toJSON() : <any>undefined;
        if (Array.isArray(this.mecs)) {
            data["mecs"] = [];
            for (let item of this.mecs)
                data["mecs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRunde {
    idRunde?: number;
    idTurnira?: number | undefined;
    runda?: number;
    idTurniraNavigation?: Turnir | undefined;
    mecs?: Mec[];
}

export class Turnir implements ITurnir {
    idTurnira?: number;
    email?: string | undefined;
    nazivTurnira?: string;
    datumOdrzavanja?: DateTime;
    lokacijaOdrzavanja?: string;
    status?: string | undefined;
    emailNavigation?: Korisnik | undefined;
    rundes?: Runde[];
    idTimas?: Tim[];

    constructor(data?: ITurnir) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idTurnira = _data["idTurnira"];
            this.email = _data["email"];
            this.nazivTurnira = _data["nazivTurnira"];
            this.datumOdrzavanja = _data["datumOdrzavanja"] ? DateTime.fromISO(_data["datumOdrzavanja"].toString()) : <any>undefined;
            this.lokacijaOdrzavanja = _data["lokacijaOdrzavanja"];
            this.status = _data["status"];
            this.emailNavigation = _data["emailNavigation"] ? Korisnik.fromJS(_data["emailNavigation"]) : <any>undefined;
            if (Array.isArray(_data["rundes"])) {
                this.rundes = [] as any;
                for (let item of _data["rundes"])
                    this.rundes!.push(Runde.fromJS(item));
            }
            if (Array.isArray(_data["idTimas"])) {
                this.idTimas = [] as any;
                for (let item of _data["idTimas"])
                    this.idTimas!.push(Tim.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Turnir {
        data = typeof data === 'object' ? data : {};
        let result = new Turnir();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idTurnira"] = this.idTurnira;
        data["email"] = this.email;
        data["nazivTurnira"] = this.nazivTurnira;
        data["datumOdrzavanja"] = this.datumOdrzavanja ? this.datumOdrzavanja.toString() : <any>undefined;
        data["lokacijaOdrzavanja"] = this.lokacijaOdrzavanja;
        data["status"] = this.status;
        data["emailNavigation"] = this.emailNavigation ? this.emailNavigation.toJSON() : <any>undefined;
        if (Array.isArray(this.rundes)) {
            data["rundes"] = [];
            for (let item of this.rundes)
                data["rundes"].push(item.toJSON());
        }
        if (Array.isArray(this.idTimas)) {
            data["idTimas"] = [];
            for (let item of this.idTimas)
                data["idTimas"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITurnir {
    idTurnira?: number;
    email?: string | undefined;
    nazivTurnira?: string;
    datumOdrzavanja?: DateTime;
    lokacijaOdrzavanja?: string;
    status?: string | undefined;
    emailNavigation?: Korisnik | undefined;
    rundes?: Runde[];
    idTimas?: Tim[];
}

export class PostGo implements IPostGo {
    idIgraca?: number | undefined;
    idTima?: number | undefined;
    idMeca?: number | undefined;
    minut?: number;

    constructor(data?: IPostGo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idIgraca = _data["idIgraca"];
            this.idTima = _data["idTima"];
            this.idMeca = _data["idMeca"];
            this.minut = _data["minut"];
        }
    }

    static fromJS(data: any): PostGo {
        data = typeof data === 'object' ? data : {};
        let result = new PostGo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idIgraca"] = this.idIgraca;
        data["idTima"] = this.idTima;
        data["idMeca"] = this.idMeca;
        data["minut"] = this.minut;
        return data;
    }
}

export interface IPostGo {
    idIgraca?: number | undefined;
    idTima?: number | undefined;
    idMeca?: number | undefined;
    minut?: number;
}

export class IgraciResponseDto implements IIgraciResponseDto {
    idIgraca?: number;
    imeIgraca?: string;
    slika?: string | undefined;
    idTima?: number | undefined;
    nazivTima?: string | undefined;
    logo?: string | undefined;

    constructor(data?: IIgraciResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idIgraca = _data["idIgraca"];
            this.imeIgraca = _data["imeIgraca"];
            this.slika = _data["slika"];
            this.idTima = _data["idTima"];
            this.nazivTima = _data["nazivTima"];
            this.logo = _data["logo"];
        }
    }

    static fromJS(data: any): IgraciResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new IgraciResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idIgraca"] = this.idIgraca;
        data["imeIgraca"] = this.imeIgraca;
        data["slika"] = this.slika;
        data["idTima"] = this.idTima;
        data["nazivTima"] = this.nazivTima;
        data["logo"] = this.logo;
        return data;
    }
}

export interface IIgraciResponseDto {
    idIgraca?: number;
    imeIgraca?: string;
    slika?: string | undefined;
    idTima?: number | undefined;
    nazivTima?: string | undefined;
    logo?: string | undefined;
}

export class SingleIgracResponseDto implements ISingleIgracResponseDto {
    idIgraca?: number;
    imeIgraca?: string;
    slika?: string | undefined;
    idTima?: number | undefined;
    nazivTima?: string | undefined;
    logo?: string | undefined;
    brGolova?: number | undefined;
    brMeceva?: number | undefined;
    brPobjeda?: number | undefined;
    brGolovaUZadnjihNMeceva?: BrGolovaPoMecu[];
    datumRodjenja?: DateTime;

    constructor(data?: ISingleIgracResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idIgraca = _data["idIgraca"];
            this.imeIgraca = _data["imeIgraca"];
            this.slika = _data["slika"];
            this.idTima = _data["idTima"];
            this.nazivTima = _data["nazivTima"];
            this.logo = _data["logo"];
            this.brGolova = _data["brGolova"];
            this.brMeceva = _data["brMeceva"];
            this.brPobjeda = _data["brPobjeda"];
            if (Array.isArray(_data["brGolovaUZadnjihNMeceva"])) {
                this.brGolovaUZadnjihNMeceva = [] as any;
                for (let item of _data["brGolovaUZadnjihNMeceva"])
                    this.brGolovaUZadnjihNMeceva!.push(BrGolovaPoMecu.fromJS(item));
            }
            this.datumRodjenja = _data["datumRodjenja"] ? DateTime.fromISO(_data["datumRodjenja"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SingleIgracResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SingleIgracResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idIgraca"] = this.idIgraca;
        data["imeIgraca"] = this.imeIgraca;
        data["slika"] = this.slika;
        data["idTima"] = this.idTima;
        data["nazivTima"] = this.nazivTima;
        data["logo"] = this.logo;
        data["brGolova"] = this.brGolova;
        data["brMeceva"] = this.brMeceva;
        data["brPobjeda"] = this.brPobjeda;
        if (Array.isArray(this.brGolovaUZadnjihNMeceva)) {
            data["brGolovaUZadnjihNMeceva"] = [];
            for (let item of this.brGolovaUZadnjihNMeceva)
                data["brGolovaUZadnjihNMeceva"].push(item.toJSON());
        }
        data["datumRodjenja"] = this.datumRodjenja ? this.datumRodjenja.toString() : <any>undefined;
        return data;
    }
}

export interface ISingleIgracResponseDto {
    idIgraca?: number;
    imeIgraca?: string;
    slika?: string | undefined;
    idTima?: number | undefined;
    nazivTima?: string | undefined;
    logo?: string | undefined;
    brGolova?: number | undefined;
    brMeceva?: number | undefined;
    brPobjeda?: number | undefined;
    brGolovaUZadnjihNMeceva?: BrGolovaPoMecu[];
    datumRodjenja?: DateTime;
}

export class BrGolovaPoMecu implements IBrGolovaPoMecu {
    idMeca?: number | undefined;
    idIgraca?: number | undefined;
    brGolova?: number | undefined;

    constructor(data?: IBrGolovaPoMecu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idMeca = _data["idMeca"];
            this.idIgraca = _data["idIgraca"];
            this.brGolova = _data["brGolova"];
        }
    }

    static fromJS(data: any): BrGolovaPoMecu {
        data = typeof data === 'object' ? data : {};
        let result = new BrGolovaPoMecu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idMeca"] = this.idMeca;
        data["idIgraca"] = this.idIgraca;
        data["brGolova"] = this.brGolova;
        return data;
    }
}

export interface IBrGolovaPoMecu {
    idMeca?: number | undefined;
    idIgraca?: number | undefined;
    brGolova?: number | undefined;
}

export class TimoviResponseDto implements ITimoviResponseDto {
    idTima?: number;
    nazivTima?: string;
    logo?: string | undefined;

    constructor(data?: ITimoviResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idTima = _data["idTima"];
            this.nazivTima = _data["nazivTima"];
            this.logo = _data["logo"];
        }
    }

    static fromJS(data: any): TimoviResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TimoviResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idTima"] = this.idTima;
        data["nazivTima"] = this.nazivTima;
        data["logo"] = this.logo;
        return data;
    }
}

export interface ITimoviResponseDto {
    idTima?: number;
    nazivTima?: string;
    logo?: string | undefined;
}

export class SingleTimResponseDto implements ISingleTimResponseDto {
    idTima?: number;
    email?: string | undefined;
    nazivTima?: string;
    logo?: string | undefined;
    igracs?: OIgracu[];
    brGolova?: number | undefined;
    brMeceva?: number | undefined;
    brPobjeda?: number | undefined;
    brGolovaUZadnjihNMeceva?: BrGolovaTimaPoMecu[];
    brojOsvojenihTurnira?: number;

    constructor(data?: ISingleTimResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idTima = _data["idTima"];
            this.email = _data["email"];
            this.nazivTima = _data["nazivTima"];
            this.logo = _data["logo"];
            if (Array.isArray(_data["igracs"])) {
                this.igracs = [] as any;
                for (let item of _data["igracs"])
                    this.igracs!.push(OIgracu.fromJS(item));
            }
            this.brGolova = _data["brGolova"];
            this.brMeceva = _data["brMeceva"];
            this.brPobjeda = _data["brPobjeda"];
            if (Array.isArray(_data["brGolovaUZadnjihNMeceva"])) {
                this.brGolovaUZadnjihNMeceva = [] as any;
                for (let item of _data["brGolovaUZadnjihNMeceva"])
                    this.brGolovaUZadnjihNMeceva!.push(BrGolovaTimaPoMecu.fromJS(item));
            }
            this.brojOsvojenihTurnira = _data["brojOsvojenihTurnira"];
        }
    }

    static fromJS(data: any): SingleTimResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SingleTimResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idTima"] = this.idTima;
        data["email"] = this.email;
        data["nazivTima"] = this.nazivTima;
        data["logo"] = this.logo;
        if (Array.isArray(this.igracs)) {
            data["igracs"] = [];
            for (let item of this.igracs)
                data["igracs"].push(item.toJSON());
        }
        data["brGolova"] = this.brGolova;
        data["brMeceva"] = this.brMeceva;
        data["brPobjeda"] = this.brPobjeda;
        if (Array.isArray(this.brGolovaUZadnjihNMeceva)) {
            data["brGolovaUZadnjihNMeceva"] = [];
            for (let item of this.brGolovaUZadnjihNMeceva)
                data["brGolovaUZadnjihNMeceva"].push(item.toJSON());
        }
        data["brojOsvojenihTurnira"] = this.brojOsvojenihTurnira;
        return data;
    }
}

export interface ISingleTimResponseDto {
    idTima?: number;
    email?: string | undefined;
    nazivTima?: string;
    logo?: string | undefined;
    igracs?: OIgracu[];
    brGolova?: number | undefined;
    brMeceva?: number | undefined;
    brPobjeda?: number | undefined;
    brGolovaUZadnjihNMeceva?: BrGolovaTimaPoMecu[];
    brojOsvojenihTurnira?: number;
}

export class OIgracu implements IOIgracu {
    idIgraca?: number;
    imeIgraca?: string;
    slika?: string | undefined;

    constructor(data?: IOIgracu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idIgraca = _data["idIgraca"];
            this.imeIgraca = _data["imeIgraca"];
            this.slika = _data["slika"];
        }
    }

    static fromJS(data: any): OIgracu {
        data = typeof data === 'object' ? data : {};
        let result = new OIgracu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idIgraca"] = this.idIgraca;
        data["imeIgraca"] = this.imeIgraca;
        data["slika"] = this.slika;
        return data;
    }
}

export interface IOIgracu {
    idIgraca?: number;
    imeIgraca?: string;
    slika?: string | undefined;
}

export class BrGolovaTimaPoMecu implements IBrGolovaTimaPoMecu {
    idMeca?: number | undefined;
    idTima?: number | undefined;
    brGolova?: number | undefined;

    constructor(data?: IBrGolovaTimaPoMecu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idMeca = _data["idMeca"];
            this.idTima = _data["idTima"];
            this.brGolova = _data["brGolova"];
        }
    }

    static fromJS(data: any): BrGolovaTimaPoMecu {
        data = typeof data === 'object' ? data : {};
        let result = new BrGolovaTimaPoMecu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idMeca"] = this.idMeca;
        data["idTima"] = this.idTima;
        data["brGolova"] = this.brGolova;
        return data;
    }
}

export interface IBrGolovaTimaPoMecu {
    idMeca?: number | undefined;
    idTima?: number | undefined;
    brGolova?: number | undefined;
}

export class TurniriResponseDto implements ITurniriResponseDto {
    idTurnira?: number;
    email?: string | undefined;
    nazivTurnira?: string;
    datumOdrzavanja?: DateTime;
    lokacijaOdrzavanja?: string;
    status?: string | undefined;

    constructor(data?: ITurniriResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idTurnira = _data["idTurnira"];
            this.email = _data["email"];
            this.nazivTurnira = _data["nazivTurnira"];
            this.datumOdrzavanja = _data["datumOdrzavanja"] ? DateTime.fromISO(_data["datumOdrzavanja"].toString()) : <any>undefined;
            this.lokacijaOdrzavanja = _data["lokacijaOdrzavanja"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): TurniriResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TurniriResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idTurnira"] = this.idTurnira;
        data["email"] = this.email;
        data["nazivTurnira"] = this.nazivTurnira;
        data["datumOdrzavanja"] = this.datumOdrzavanja ? this.datumOdrzavanja.toString() : <any>undefined;
        data["lokacijaOdrzavanja"] = this.lokacijaOdrzavanja;
        data["status"] = this.status;
        return data;
    }
}

export interface ITurniriResponseDto {
    idTurnira?: number;
    email?: string | undefined;
    nazivTurnira?: string;
    datumOdrzavanja?: DateTime;
    lokacijaOdrzavanja?: string;
    status?: string | undefined;
}

export class SingleTurnirResponseDto implements ISingleTurnirResponseDto {
    idTurnira?: number;
    email?: string | undefined;
    nazivTurnira?: string;
    datumOdrzavanja?: DateTime;
    lokacijaOdrzavanja?: string;
    status?: string | undefined;
    rundes?: RundeResponseDto[];
    timovi?: TimoviResponseDto[];

    constructor(data?: ISingleTurnirResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idTurnira = _data["idTurnira"];
            this.email = _data["email"];
            this.nazivTurnira = _data["nazivTurnira"];
            this.datumOdrzavanja = _data["datumOdrzavanja"] ? DateTime.fromISO(_data["datumOdrzavanja"].toString()) : <any>undefined;
            this.lokacijaOdrzavanja = _data["lokacijaOdrzavanja"];
            this.status = _data["status"];
            if (Array.isArray(_data["rundes"])) {
                this.rundes = [] as any;
                for (let item of _data["rundes"])
                    this.rundes!.push(RundeResponseDto.fromJS(item));
            }
            if (Array.isArray(_data["timovi"])) {
                this.timovi = [] as any;
                for (let item of _data["timovi"])
                    this.timovi!.push(TimoviResponseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SingleTurnirResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SingleTurnirResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idTurnira"] = this.idTurnira;
        data["email"] = this.email;
        data["nazivTurnira"] = this.nazivTurnira;
        data["datumOdrzavanja"] = this.datumOdrzavanja ? this.datumOdrzavanja.toString() : <any>undefined;
        data["lokacijaOdrzavanja"] = this.lokacijaOdrzavanja;
        data["status"] = this.status;
        if (Array.isArray(this.rundes)) {
            data["rundes"] = [];
            for (let item of this.rundes)
                data["rundes"].push(item.toJSON());
        }
        if (Array.isArray(this.timovi)) {
            data["timovi"] = [];
            for (let item of this.timovi)
                data["timovi"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISingleTurnirResponseDto {
    idTurnira?: number;
    email?: string | undefined;
    nazivTurnira?: string;
    datumOdrzavanja?: DateTime;
    lokacijaOdrzavanja?: string;
    status?: string | undefined;
    rundes?: RundeResponseDto[];
    timovi?: TimoviResponseDto[];
}

export class RundeResponseDto implements IRundeResponseDto {
    idRunde?: number;
    idTurnira?: number | undefined;
    runda?: number;
    mecs?: MecResponseDTO[];

    constructor(data?: IRundeResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idRunde = _data["idRunde"];
            this.idTurnira = _data["idTurnira"];
            this.runda = _data["runda"];
            if (Array.isArray(_data["mecs"])) {
                this.mecs = [] as any;
                for (let item of _data["mecs"])
                    this.mecs!.push(MecResponseDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RundeResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new RundeResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idRunde"] = this.idRunde;
        data["idTurnira"] = this.idTurnira;
        data["runda"] = this.runda;
        if (Array.isArray(this.mecs)) {
            data["mecs"] = [];
            for (let item of this.mecs)
                data["mecs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRundeResponseDto {
    idRunde?: number;
    idTurnira?: number | undefined;
    runda?: number;
    mecs?: MecResponseDTO[];
}

export class MecResponseDTO implements IMecResponseDTO {
    idMeca?: number;
    idRunde?: number | undefined;
    idPobjednika?: number | undefined;
    idTima1?: number | undefined;
    idTima2?: number | undefined;
    brGolovaTim1?: number | undefined;
    brGolovaTim2?: number | undefined;
    mecZavrsen?: boolean;
    gos?: GoloviResponseDTO[];

    constructor(data?: IMecResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idMeca = _data["idMeca"];
            this.idRunde = _data["idRunde"];
            this.idPobjednika = _data["idPobjednika"];
            this.idTima1 = _data["idTima1"];
            this.idTima2 = _data["idTima2"];
            this.brGolovaTim1 = _data["brGolovaTim1"];
            this.brGolovaTim2 = _data["brGolovaTim2"];
            this.mecZavrsen = _data["mecZavrsen"];
            if (Array.isArray(_data["gos"])) {
                this.gos = [] as any;
                for (let item of _data["gos"])
                    this.gos!.push(GoloviResponseDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MecResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MecResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idMeca"] = this.idMeca;
        data["idRunde"] = this.idRunde;
        data["idPobjednika"] = this.idPobjednika;
        data["idTima1"] = this.idTima1;
        data["idTima2"] = this.idTima2;
        data["brGolovaTim1"] = this.brGolovaTim1;
        data["brGolovaTim2"] = this.brGolovaTim2;
        data["mecZavrsen"] = this.mecZavrsen;
        if (Array.isArray(this.gos)) {
            data["gos"] = [];
            for (let item of this.gos)
                data["gos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMecResponseDTO {
    idMeca?: number;
    idRunde?: number | undefined;
    idPobjednika?: number | undefined;
    idTima1?: number | undefined;
    idTima2?: number | undefined;
    brGolovaTim1?: number | undefined;
    brGolovaTim2?: number | undefined;
    mecZavrsen?: boolean;
    gos?: GoloviResponseDTO[];
}

export class GoloviResponseDTO implements IGoloviResponseDTO {
    idGola?: number;
    idIgraca?: number | undefined;
    idTima?: number | undefined;
    idMeca?: number | undefined;
    minut?: number;
    imeIgraca?: string;

    constructor(data?: IGoloviResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idGola = _data["idGola"];
            this.idIgraca = _data["idIgraca"];
            this.idTima = _data["idTima"];
            this.idMeca = _data["idMeca"];
            this.minut = _data["minut"];
            this.imeIgraca = _data["imeIgraca"];
        }
    }

    static fromJS(data: any): GoloviResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GoloviResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idGola"] = this.idGola;
        data["idIgraca"] = this.idIgraca;
        data["idTima"] = this.idTima;
        data["idMeca"] = this.idMeca;
        data["minut"] = this.minut;
        data["imeIgraca"] = this.imeIgraca;
        return data;
    }
}

export interface IGoloviResponseDTO {
    idGola?: number;
    idIgraca?: number | undefined;
    idTima?: number | undefined;
    idMeca?: number | undefined;
    minut?: number;
    imeIgraca?: string;
}

export class PostTurnirDTO implements IPostTurnirDTO {
    email?: string | undefined;
    nazivTurnira?: string;
    datumOdrzavanja?: DateTime;
    lokacijaOdrzavanja?: string;

    constructor(data?: IPostTurnirDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.nazivTurnira = _data["nazivTurnira"];
            this.datumOdrzavanja = _data["datumOdrzavanja"] ? DateTime.fromISO(_data["datumOdrzavanja"].toString()) : <any>undefined;
            this.lokacijaOdrzavanja = _data["lokacijaOdrzavanja"];
        }
    }

    static fromJS(data: any): PostTurnirDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PostTurnirDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["nazivTurnira"] = this.nazivTurnira;
        data["datumOdrzavanja"] = this.datumOdrzavanja ? this.datumOdrzavanja.toString() : <any>undefined;
        data["lokacijaOdrzavanja"] = this.lokacijaOdrzavanja;
        return data;
    }
}

export interface IPostTurnirDTO {
    email?: string | undefined;
    nazivTurnira?: string;
    datumOdrzavanja?: DateTime;
    lokacijaOdrzavanja?: string;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}